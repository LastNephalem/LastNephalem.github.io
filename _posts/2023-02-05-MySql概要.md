---
title: MySQL概要
date: 2023-02-05 20:14:15 +0800 
categories: [storage, MySQL]
tags: [history, MySQL, middleware, storage] 
---
### MySQL概要

#### 1. 架构与历史

#### 1.1 Mysql的逻辑架构

![image-20210529094657583.png](/assets/img/2023-02-05-MySql概要/image-20210529094657583.png)

- 最上层：mysql连接处理，授权认证等
- 第二层：优化器，解析器，查询缓存；跨存储引擎部分技术：存储过程，触发器，视图
- 第三层：Mysql中数据的存储和提取。不同存储引擎有差异，主要了解InnoDB数据引擎。

#### 1.2 并发控制

- 读写锁（排他锁和共享锁）
- 锁的粒度
    - 表锁
    - 行锁（在存储引擎层实现，InnoDB具有行锁），***只有走索引才能使用行锁，否则执行表锁。***
    - 优缺点：
        - **表级锁：**开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
        - **行级锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 加锁方式
    - 隐式加锁，更新等操作存储引擎自动加锁，未commmit时，锁定；commit后释放
    - 显示加锁，select … for update / in share mode


    
#### 2. 索引基础

#### 2.1 索引存储结构种类

#### 2.1.1 B-Tree 索引（InnoDB数据引擎）常用

![image-20210531112222285-1622431355964.png](/assets/img/2023-02-05-MySql概要/image-20210531112222285-1622431355964.png)

通过比较Key的值进行一层层寻找

- B-Tree联合索引限制
    - 最左匹配原则。不是按照索引的最左列查找，无法使用索引；
    - 不能跳过索引中的列，否则只按照第一列进行查找
    - 若联合索引中有某个列的范围查询，则其右边的列都无法使用索引优化查找。**若查询范围列值有限，可以通过多个等于条件来代替范围条件**
- 索引种类
    - 主键
    - 唯一索引
    - 普通索引

#### 2.1.2 哈希索引 （Memory引擎）

**注意：** 只有**精确查询**有效

哈希索引的限制：

- 哈希索引只包含哈希值和行指针，不存储数据。
- 不是顺序存储，无法排序，范围查询
- 只支持等值比较
- 存在哈希冲突，冲突出现需要逐条遍历

#### 2.1.3 R-Tree 空间数据索引（R-Tree）

存储地理数据

#### 2.1.4 全文索引

查找文本中的关键词，非直接比较索引中的值

#### 2.2 索引优势

1. 索引减少了服务器所需扫描的数据量
2. 索引可以帮助服务避免排序和临时表
3. 索引可以将随机I/O转化为顺序I/O

#### 2.3 索引匹配方式

- 全值匹配：全值匹配指的是和索引中的所有列进行匹配
- 匹配最左前缀：只匹配前面的几列
- 匹配列前缀：可以匹配某一列的值的开头部分
- 匹配范围值：可以查找某一个范围的数据
- 精确匹配某一列并范围匹配另外一列：可以查询第一列的全部和第二列的部分
- 只访问索引的查询（索引覆盖）

**索引并不总是最好的工具。** 只有索引能帮助存储引擎快速查到记录带来好处大于其带来的额外工作时，索引才有效。

#### 2.4 高性能索引策略

#### 2.4.1 单列索引

带表达式的查询无法使用索引

#### 2.4.2 前缀索引和索引选择性

- 索引需要很长的字符列，可以用哈希索引，或者前缀索引
- 索引的**选择性**是指： 不重复索引值数量（基数）和总记录数（#T）的比值，范围从1/#T到1之间。选择性越高，则查询效率越高。
- 对于前缀索引，试验后发现 长度为**7** 比较合适

#### 2.4.3 多列索引

多个单列索引的基础上，where 条件中都涉及了索引列，会进行索引查找后合并，称为索引合并策略优化。（说明索引建的很糟糕）

- **And：** 相交（intersection）
- **OR：** 联合（union）
- 组合以上两种情况

#### 2.4.4 选择合适的索引列顺序

性能不能只依赖索引的**选择性**， 也要考虑索引列的值，以及值的分布情况

#### 2.4.5 聚簇索引

聚簇索引是B-Tree的存储方式

![image-20210531140616425-1622441192771.png](/assets/img/2023-02-05-MySql概要/image-20210531140616425-1622441192771.png)

聚簇索引的存储方式

**优势：**

- 可以将相关的数据存在一起，减少I/O次数
- 数据访问更快。聚簇索引将索引和数据放在同一个B-Tree中，获取数据更快
- 使用覆盖索引扫描查询可以直接是使用页节点中的主键值

缺点：

- 提高了I/O密集型i应用的性能，若数据在内存中，访问顺序不重要了，聚簇索引没有优势了
- 插入速度依赖与插入顺序，顺序不对会频繁调整索引结构
- 更新索引列的代价很高
- 二级索引占用空间大
- 可能需要查到主键值后，在去查行号
    
![image-20210531141845958-1622441939536.png](/assets/img/2023-02-05-MySql概要/image-20210531141845958-1622441939536.png)
    

聚簇和非聚簇

#### 2.4.6 避免重复索引

#### 2.4.7 索引覆盖

1、如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引

2、不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值

3、不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，memory不支持覆盖索引

**索引覆盖优势：**

1、索引条目通常远小于数据行大小，如果只需要读取索引，那么mysql就会极大的较少数据访问量

2、因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多

3、一些存储引擎如MYISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这可能会导致严重的性能问题

4、由于INNODB的聚簇索引，覆盖索引对INNODB表特别有用

#### 3. MySQL数据类型

MySQL中定义数据字段的类型对你数据库的优化是非常重要的。

MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。

#### 3.1 数值类型

- BIT(M) 位类型 M代表位数， 取值1-64
- TINYINT(M) [UNSIGNED] [ZEROFILL] 一个字节，M长度，与类型存储大小无关
- BOOLEAN，BOOL 布尔类型， 类似于TINYINT(1), 0 = false 1= true
- TINYINT(M) [UNSIGNED] [ZEROFILL]


#### 3. mysql关键字的执行顺序

![image-20210529110434695.png](/assets/img/2023-02-05-MySql概要/image-20210529110434695.png)
