---
title: 设计模式概要
date: 2023-02-05 19:14:15 +0800 
categories: [design_patterns]
tags: [interface, design_patterns] 
---

### 设计模式

软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。

#### 学习原因

- 提高复杂代码的设计和开发能力

​ 规范代码书写，做到代码的易扩展、易用、易维护

- 让读源码、学框架事半功倍

​ 更容易的读懂源码，更加深刻体会其中的设计精髓

- 为职场发展做铺垫

#### 代码的评价方式

![image-20210723093957129.png](/assets/img/2023-02-05-设计模式概要/image-20210723093957129.png)

多维度评价代码质量，维度存在重合、包含关系等，各种维度也不是非黑即白的；

评价代码带有一定主观性，跟工程师的经验相关，越有经验，评价越准。

#### 常用标准

- 可维护性：维护、易维护、不易维护
    - 在不破坏原有代码设计、不引入新bug的情况下，快速添加、修改代码
- 可读性：易读、易理解
    - 是否符合编码规范、是否符合高内聚低耦合
    - 衡量标准：同事看你代码没有很多疑问
- 可扩展性：不修改原有代码的情况下，扩展新的功能
    - 代码预留扩展点
- 灵活性
    - 易扩展
    - 底层很多可以复用的模块
    - 接口的易用性
- 简洁性 KISS
    - 思从深而行简，用最简单的方法解决问题
    - KISS Keep it Simple, Stupid 理解下
- 可复用性 （**Do not repeat yourself!!**）
    - 继承、多态（面向对象）
    - 单一职责（设计原则）
    - 解耦、高内聚、模块化（重构技巧）
- 可测试性
    - 反应代码质量好坏
    
#### 如何写出高质量的代码 

需要掌握更加细化、更加能落地的贬称该方法论，包括面向对象的设计思想，设计原则，设计模式，编码规范、重构技巧等。

---

#### 面向对象

主流的编程风格：面向过程、**面向对象**和函数式编程

- 面向对象4大特性：封装、**抽象**、继承、多态
    - 封装：信息隐藏数据访问保护，暴露有限的接口访问相应的数据（**访问权限控制**）
    - 抽象：隐藏方法的具体实现，忽略非关键行的实现细节
    - 继承：标识类之间 `is-a`的关系，解决代码复用 问题。**“多用组合少用继承”**
    - 多态：1、继承；2、父类对象引用子类对象；3、方法重写
- 面向过程和面向对象的区别和联系

​ 面向过程和面向对象最基本的区别就是，代码的**组织方式不同**。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），**方法**和**数据结构**的定义是分开的。面向对象风格的代码被组织成一组类，**方法和数据结构**被绑定一起，定义在类中。

​ 面向对象优势：

​ 1、OOP 更加能够应对大规模复杂程序的开发

​ 2、OOP 风格的代码更易复用、易扩展、易维护

​ 3、OOP 语言更加人性化、更加高级、更加智能

**哪些代码看似面向对象，实际是面向过程的？**

1. 滥用get、set方法
    - 所有属性都添加get、set方法
    - get方法返回集合类，可以对集合进行修改，破环了封装性
2. 滥用全局变量和全局方法
    - Constants、Utils类，将方法和数据分离，破坏了面向对象结构
3. 定义数据和方法分离的类 （贫血开发模式）
    - MVC架构，VO、BO中只定义数据，逻辑都在service层，面向过程的风格
- 面向对象分析、面向对象设计、面向对象编程 （**UML，统一建模语言**）
- **接口和抽象类的区别以及各自的应用场景**
    - 抽象类有成员变量和方法实现，不能被实例化；接口只能有常数，不能有方法实现（java8中加入了默认方法）
    - 抽象类是`is-a`的关系，接口是`has-a` 或者`behaves like`的关系；**接口**可以看成是一种标准 **协议**或者 **约定**。
    - “基于接口而非实现编程”，灵活性，扩展性
- 基于接口而非实现编程的设计思想（能体会到，但可能表述不清）

​ 越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且再将来需求发生变化的时候，仍然能够再不破坏原有代码设计的情况下灵活应对。

​ 为啥推荐**多用组合少用继承** ？

​ 继承代码耦合度过高，父类代码修改影响所有子类逻辑；继承层次过深、继承关系过于复杂影响可读性和维护性。

 组合、接口、委托三种方式能够能很好的实现继承的特性；但是粒度过细，接口和类的增多，维护难度也大。

![image-20210727094533725.png](/assets/img/2023-02-05-设计模式概要/image-20210727094533725.png)

组合 和 继承 要看情况使用，一般情况，类结构稳定，继承层次较浅，可以考虑使用继承；反之使用接口。特殊情况特殊考虑。

- 面向过程的**贫血模型**和面向对象的**充血模型**（实战虚拟钱包、鉴权）
    - 贫血模型：只包含数据，不包含任何逻辑的的类。例如：一般的MVC架构
    - 充血模型：数据和逻辑被包装到同一个类中，满足面向对象的封装特性。例如：**DDD**

#### 设计原则

设计原则是指导我们代码设计的一些经验总结。对于每一种设计原则，要了解设计初衷。

- SOLIDY原则-SRP单一职责原则
    - 单个class/module只负责完成一个职责和功能
    - 如何判断一个类是否满足单一职责
        - 代码行数、函数、或者属性过多
        - 类依赖的其他类过多
        - 私有方法过多
        - 起名困难
        - 类中大量操作针对类中的某些属性
- SOLIDY原则-OCP开闭原则
    - 对扩展开放，对修改关闭
    - 扩展意识、抽象意识、封装意识
- SOLIDY原则-LSP里氏替换原则
    - 子类对象能够替换父类对象，保证原来的逻辑行为和正确性
    - 父类定义了函数的行为约定，子类可以改变函数的内部实现，但不能改变函数的行为约定。
        - 函数声明要实现的功能
        - 对输出、输入、异常的约定
        - 包括注释中约定的任何说明
- SOLIDY原则-ISP接口隔离原则
    - 接口粒度划分，接口设计
    - 判断接口是否满足接口单一职责原则
- SOLIDY原则-DIP依赖倒置原则 （有没有个例子啊？）
    - 高层模块（high-level modules）不要依赖于底层模块。
        - 高层模块和底层模块应该通过抽象来相互依赖
        - 抽象不要具体依赖于实现细节
- DRY原则、KISS原则、**YAGNI原则**、**LOD法则**
    - KISS原则
        - 不是代码行数越少越好，需要保证代码的可读性和可维护性
        - 注意不要过度优化
        - 考虑业务使用场景，选择恰当的匹配算法
    - YAGNAI: You Ain’t Gonna Need It. 不要做过度设计。
    - DRY原则，Don’t repeat yourself
        - 功能语义重复
        - 实现逻辑重复
        - 代码重复执行
    - 代码的复用性
        - 减少代码耦合
        - 满足单一职责原则
        - 模块化
        - 业务与非业务逻辑分离
        - 通用代码下沉
        - 继承、多态、抽象、封装
        - 应用模板设计模式
    - LOD原则 （迪米特法则）
        - 最少知识原则，类之间的关系
        - LOD松耦合，可能违反“**高内聚**”

**为啥要分MVC三层开发？**

- 分层能起到代码复用的作用
- 分层能起到隔离变化的作用
- 分才能起到隔离关注点的作用
- 分层提高代码的可测试性
- 分层能应对系的复杂性

**BO、VO、Entity作用，存在的意义？**

- 不违反DRY原则，语义能说通，更好的划分边界
- 对于重复代码，通过继承、组合的方式解决
- 所在层次不同，生命周期是有限的，

#### SOLIDY原则

##### 1.开闭原则

含义：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

###### 开闭原则的作用

开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。

1、对软件测试的影响  
软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

2、可以提高代码的可复用性  
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

3、可以提高软件的可维护性  
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

###### 开闭原则的实现方法

可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

##### 2.里氏替换原则

里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。

里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

###### 里氏替换原则的作用

1. 里氏替换原则是实现开闭原则的重要方式之一。
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

###### 里氏替换原则的实现方法

里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

根据上述理解，对里氏替换原则的定义可以总结如下：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。

##### 3.依赖倒置原则

依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 [C++](http://c.biancheng.net/cplus/) Report 上发表的文章。

依赖倒置原则的原始定义为：**高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象**（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：**要面向接口编程，不要面向实现编程**。

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

###### 依赖、倒置原则的作用

依赖倒置原则的主要作用如下。

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。

###### 依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

##### 4.单一职责

单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。

该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

###### 单一职责原则的优点

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。

- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂性降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

###### 单一职责原则的实现方法

单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。

##### 5.接口隔离原则

接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。

以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

###### 接口隔离原则的优点

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
3. 如果接口的**粒度大小定义合理**，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

###### 接口隔离原则的实现方法

在具体应用接口隔离原则时，应该根据以下几个规则来衡量。

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

##### 6.迪米特法则

迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。

迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

###### 迪米特法则的优点

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

###### 迪米特法则的实现方法

从迪米特法则的定义和特点可知，它强调以下两点：

1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。

所以，在运用迪米特法则时要注意以下 6 点。

1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
2. 在类的结构设计上，尽量降低类成员的访问权限。
3. 在类的设计上，优先考虑将一个类设置成不变类。
4. 在对其他类的引用上，将引用其他对象的次数降到最低。
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
6. 谨慎使用序列化（Serializable）功能。

##### 7.合成复用原则

合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。

###### 合成复用原则的重要性

通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。

1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

###### 合成复用原则的实现方法

合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

> 记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。

##### 设计模式

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思 路。大部分设计模式要解决的都是代码的可扩展性问题。

1. 创建型 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。 不常用的有：原型模式。
2. 结构型 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。 不常用的有：门面模式、组合模式、享元模式。
3. 行为型 SOLID 原则 -DIP 依赖倒置原则 DRY 原则、KISS 原则、YAGNI 原则、LOD 法则 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。 编程

##### 1、单例 ： 支持懒加载的双重检测不比饿汉式更优

一个类只允许创建一个对象（实例），这个类就是一个单例类。（单例模式）

- 使用单例的原因
    - 处理资源访问冲突
    - 全局唯一的类：有些数据再系统中只应保存一份（配置文件）
- 单例存在的问题 **（违背OOP多态、继承、抽象原则）**
    - 实现方式
        - 私有化构造函数
        - 考虑对象创建的线程安全问题
        - 考虑是否支持延迟加载
        - 考虑getInstence() 性能 是否高
    - 饿汉式实现单例，静态实例化的时候就创建好了，但不支持延迟加载，资源浪费，OOM
        - fail-fast原则，问题越早暴露越好，资源不够，不要懒加载才暴露
    - 懒汉式给getInstence()方法加一把大锁 synchronized
        - 频繁的释放、加锁，性能差
    - 双重检测 缩小锁的粒度，成员变量加上volatile关键字，禁止指令重排序
    - 单例对OOP的实现方式支持不友好
    - 单例会隐藏类之间的依赖关系
    - 单例对代码的扩展性不好
    - 单例不支持有参的构造函数
        - 创建完实例，使用init()函数传递参数
        - getInstence(参数)
        - 使用全局变量（推荐）
- 单例与静态类的区别
- 代替的解决方案
    - 静态内部类能够实现单例模式，比双重检验更加简单
    
    ```java
    public class IdGenerator {
       private AtomicLong id = new AtomicLong(0);    
       private IdGenerator(){}    
        private static class SingletonHolder {        
           private static final IdGenerator instance = new IdGenerator();    
        }    
        public static IdGenerator getInstence() {        
           return SingletonHolder.instence;    
        }    
    }
    ```
    
    SingletonHolder 是一个静态内部类，当外部类创建时，不会创建SingletonHolder实例对象，调用时才会被加载
    
    - 枚举
    
    ```java
    public enum IdGenerator{    
  
        Instence;    
        
      private AtomicLong id = new AtomicLong(0);    
       //...
    }
    ```
    
    通过枚举类本身的特性保证线程安全
    

**如何理解单例模式中的唯一性？**

- 只创建一个实例
- 进程内是唯一，进程间是不唯一的

**如何实现线程唯一单例？**

- 线程唯一和进程唯一的区别
- ThreadLocal工具类使用

**如何实现集群环境下的单例？**

- 本质上是进程间唯一
- 初步思考存储外部共享存储空间，每次使用读共享存储空间

##### 2、工厂模式

工厂模式：对象创建逻辑复杂，将对象创建和使用分离，一般有一下两种情况：

1. 动态地根据不同的条件创建不同的对象，对象创建过程中有大量的if-else语句；
2. 单个类对象的创建本身比较复杂，需要组合其他对象，做各种初始化操作等

从设计原则和思想层面考虑工厂模式：

- 封装变化：创建逻辑复杂，可能变化，创建对象过程对调用者透明
- 代码复用：复杂对象创建过程可复用
- 隔离复杂性：复杂的创建过程对调用者透明
- 控制复杂度：对象创建和使用分离，降低原来类的复杂度，职责更加单一，代码简洁

简单工厂、工厂方法、抽象工厂

**简单工厂**

- 将对象创建抽到一个类中，这个类就是工厂类
    - 结合单例模式，通过hashmap 做缓存，实现对象复用
    - 简单工厂中代码中出现大量的if语句违背开闭原则

**工厂方法**

抽象工厂比简单工厂更加符合开闭原则

- 多态，相同的方法抽出一个接口，实现这个接口
- 可以再建造一个工厂，即工厂的工厂，来new 出 不同的工厂

**简单工厂 vs 工厂方法**

- 简单工厂：对象创建简单；若是返回对象不同，需要大量的if-else语句
- 工厂方法：对象创建过程复杂，可以将复杂的创建逻辑分布到各个不同的工厂中

**抽象工厂 ？？？？**

##### 3、建造者模式

对于复杂的对象，通过构造器建立对象可能出现疏忽，对于配置类来说，大量的成员变量需要设定，直通new 来创建可能出现疏漏，而Builder 模式则可以很好的避免这个问题，需要设定什么，就传什么，其他用默认值。

对象中有set函数，为啥还需要build函数，三个维度：

- 存放校验必填项的校验逻辑
- 配置项之间的依赖关系或者约束条件的校验逻辑
- 一般的Config类是不可变类，不能够暴露set方法
- 避免出现类无效的情况，如下

```java
    Rectangle r = new Rectangle(); // r is invalidr.setWidth(2);                 // r is invalidr.setHeight(3);                // r is valid
```

**与工厂模式的区别**

- 工厂模式是为了“定制化”的创建对象，根据传参的不同，创建不同的对象（一组类的创建）
- 建造者模式 是 单个 类的创建

##### 4、原型模式

**原理：** 如果对象的创建成本比较大，而通过一个类的不同对象之间差别不大（大部分字段相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（拷贝）的方式来创建新对象，以达到节省创建时间的目的，**这种基于原型**的设计模式，简称原型模式。

何为“**对象创建的成本比较大**”？

- 对象创建对象包含的申请内存，成员变量复制 不会 花费多少资源，不要过度设计（刚学的时候，真想那么干）
- 对象数据需要经过复杂对象才能得到（比如排序、计算哈希值），或者需要rpc、网络、io、数据库或者文件中读取，这种情况考虑原型模式。
